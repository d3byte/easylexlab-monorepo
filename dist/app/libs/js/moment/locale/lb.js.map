{"version":3,"sources":["../../../../../../server/app/libs/js/moment/locale/lb.js"],"names":["factory","define","amd","exports","module","require","global","moment","processRelativeTime","number","withoutSuffix","key","isFuture","format","processFutureTime","string","substr","indexOf","eifelerRegelAppliesToNumber","processPastTime","parseInt","isNaN","lastDigit","firstDigit","defineLocale","months","split","monthsShort","weekdays","weekdaysShort","weekdaysMin","longDateFormat","LT","LTS","L","LL","LLL","LLLL","calendar","sameDay","sameElse","nextDay","nextWeek","lastDay","lastWeek","day","relativeTime","future","past","s","m","mm","h","hh","d","dd","M","MM","y","yy","ordinalParse","ordinal","week","dow","doy"],"mappings":"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","file":"lb.js","sourcesContent":["// moment.js locale configuration\r\n// locale : Luxembourgish (lb)\r\n// author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz\r\n\r\n// Note: Luxembourgish has a very particular phonological rule ('Eifeler Regel') that causes the\r\n// deletion of the final 'n' in certain contexts. That's what the 'eifelerRegelAppliesToWeekday'\r\n// and 'eifelerRegelAppliesToNumber' methods are meant for\r\n\r\n(function (factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['moment'], factory); // AMD\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('../moment')); // Node\r\n    } else {\r\n        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global\r\n    }\r\n}(function (moment) {\r\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\r\n        var format = {\r\n            'm': ['eng Minutt', 'enger Minutt'],\r\n            'h': ['eng Stonn', 'enger Stonn'],\r\n            'd': ['een Dag', 'engem Dag'],\r\n            'M': ['ee Mount', 'engem Mount'],\r\n            'y': ['ee Joer', 'engem Joer']\r\n        };\r\n        return withoutSuffix ? format[key][0] : format[key][1];\r\n    }\r\n\r\n    function processFutureTime(string) {\r\n        var number = string.substr(0, string.indexOf(' '));\r\n        if (eifelerRegelAppliesToNumber(number)) {\r\n            return 'a ' + string;\r\n        }\r\n        return 'an ' + string;\r\n    }\r\n\r\n    function processPastTime(string) {\r\n        var number = string.substr(0, string.indexOf(' '));\r\n        if (eifelerRegelAppliesToNumber(number)) {\r\n            return 'viru ' + string;\r\n        }\r\n        return 'virun ' + string;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the word before the given number loses the '-n' ending.\r\n     * e.g. 'an 10 Deeg' but 'a 5 Deeg'\r\n     *\r\n     * @param number {integer}\r\n     * @returns {boolean}\r\n     */\r\n    function eifelerRegelAppliesToNumber(number) {\r\n        number = parseInt(number, 10);\r\n        if (isNaN(number)) {\r\n            return false;\r\n        }\r\n        if (number < 0) {\r\n            // Negative Number --> always true\r\n            return true;\r\n        } else if (number < 10) {\r\n            // Only 1 digit\r\n            if (4 <= number && number <= 7) {\r\n                return true;\r\n            }\r\n            return false;\r\n        } else if (number < 100) {\r\n            // 2 digits\r\n            var lastDigit = number % 10, firstDigit = number / 10;\r\n            if (lastDigit === 0) {\r\n                return eifelerRegelAppliesToNumber(firstDigit);\r\n            }\r\n            return eifelerRegelAppliesToNumber(lastDigit);\r\n        } else if (number < 10000) {\r\n            // 3 or 4 digits --> recursively check first digit\r\n            while (number >= 10) {\r\n                number = number / 10;\r\n            }\r\n            return eifelerRegelAppliesToNumber(number);\r\n        } else {\r\n            // Anything larger than 4 digits: recursively check first n-3 digits\r\n            number = number / 1000;\r\n            return eifelerRegelAppliesToNumber(number);\r\n        }\r\n    }\r\n\r\n    return moment.defineLocale('lb', {\r\n        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),\r\n        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),\r\n        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),\r\n        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),\r\n        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),\r\n        longDateFormat: {\r\n            LT: 'H:mm [Auer]',\r\n            LTS: 'H:mm:ss [Auer]',\r\n            L: 'DD.MM.YYYY',\r\n            LL: 'D. MMMM YYYY',\r\n            LLL: 'D. MMMM YYYY LT',\r\n            LLLL: 'dddd, D. MMMM YYYY LT'\r\n        },\r\n        calendar: {\r\n            sameDay: '[Haut um] LT',\r\n            sameElse: 'L',\r\n            nextDay: '[Muer um] LT',\r\n            nextWeek: 'dddd [um] LT',\r\n            lastDay: '[Gëschter um] LT',\r\n            lastWeek: function () {\r\n                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule\r\n                switch (this.day()) {\r\n                    case 2:\r\n                    case 4:\r\n                        return '[Leschten] dddd [um] LT';\r\n                    default:\r\n                        return '[Leschte] dddd [um] LT';\r\n                }\r\n            }\r\n        },\r\n        relativeTime : {\r\n            future : processFutureTime,\r\n            past : processPastTime,\r\n            s : 'e puer Sekonnen',\r\n            m : processRelativeTime,\r\n            mm : '%d Minutten',\r\n            h : processRelativeTime,\r\n            hh : '%d Stonnen',\r\n            d : processRelativeTime,\r\n            dd : '%d Deeg',\r\n            M : processRelativeTime,\r\n            MM : '%d Méint',\r\n            y : processRelativeTime,\r\n            yy : '%d Joer'\r\n        },\r\n        ordinalParse: /\\d{1,2}\\./,\r\n        ordinal: '%d.',\r\n        week: {\r\n            dow: 1, // Monday is the first day of the week.\r\n            doy: 4  // The week that contains Jan 4th is the first week of the year.\r\n        }\r\n    });\r\n}));\r\n"]}